use std::sync::{Arc, RwLock};

use fp_core::{hooks::{hook_registry::HookClosure, typemap::TypeMap}, core::{packet::PacketContext, errors::HookError}};

use crate::{packet::dhcp_packet::DhcpV4Packet, cfg::main_cfg::NetworkCfg};


pub fn responder_hook() -> HookClosure<DhcpV4Packet, DhcpV4Packet>{

    let responder_hook = HookClosure(Box::new(
        |services: Arc<RwLock<TypeMap>>, context: &mut PacketContext<DhcpV4Packet, DhcpV4Packet>| {
            
            _fill_dhcp_header(services.clone(), context)?;
            match context.get_input().options.message_type().unwrap() {
                1 => {
                    _handle_dhcp_discover(services, context) 
                }
                3 => {
                    _handle_dhcp_request(services, context)
                }
                _ => Ok(1)
            }

        }
    ));
    responder_hook

}

fn _fill_dhcp_header(
    services: Arc<RwLock<TypeMap>>,
    context: &mut PacketContext<DhcpV4Packet, DhcpV4Packet>
) -> Result<(), HookError> {

    let input = context.get_input().clone();
    let output = context.get_mut_output();
    let cfg = services.read().unwrap();
    let net_cfg = cfg.get::<Arc<RwLock<NetworkCfg>>>()
        .ok_or(HookError::new("Failed to retrieve network configuration."))?
        .read()
        .unwrap();

    output.op = 2;
    output.htype = 1;
    output.hlen = 6;
    output.hops = 0;
    output.xid = input.xid;
    output.giaddr = input.giaddr;
    output.chadd = input.chadd;
    output.options.set_server_identifier(net_cfg.ipv4());
    output.options.set_client_identifier(
        input.options
            .client_identifier()
            .map(|x| x.clone())
    );

    Ok(())
}

fn _handle_dhcp_discover (
    services: Arc<RwLock<TypeMap>>,
    context: &mut PacketContext<DhcpV4Packet, DhcpV4Packet>
) -> Result<isize, HookError> {

    let input = context.get_input().clone();
    let output = context.get_mut_output();

    output.options.set_message_type(Some(2));

    Ok(0)
}

fn _handle_dhcp_request (
    services: Arc<RwLock<TypeMap>>,
    context: &mut PacketContext<DhcpV4Packet, DhcpV4Packet>
) -> Result<isize, HookError> {
    Ok(0)
}

#[cfg(test)]
mod tests {
    use std::{sync::{Arc, RwLock}, net::Ipv4Addr};

    use fp_core::{core::packet::{PacketType, PacketContext}, hooks::hook_registry::{HookRegistry, Hook, HookClosure}};

    use crate::{packet::dhcp_packet::DhcpV4Packet, cfg::main_cfg::load_main_cfg};

    use super::responder_hook;


    const INPUT_DHCP_DISCOVER: [u8; 308] = [
      0x01, 0x01, 0x06, 0x00, 0xab, 0xcd, 0x00, 0x03,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x48, 0x55, 0x19, 0xc8,
      0x57, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x63, 0x82, 0x53, 0x63,
      0x35, 0x01, 0x01, 0x39, 0x02, 0x05, 0xdc, 0x0c,
      0x0a, 0x45, 0x53, 0x50, 0x5f, 0x43, 0x38, 0x35,
      0x37, 0x33, 0x44, 0x37, 0x0c, 0x01, 0x03, 0x1c,
      0x06, 0x0f, 0x2c, 0x2e, 0x2f, 0x1f, 0x21, 0x79,
      0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ];

    #[test]
    fn test_dhcp_discover_responder() {

        let input_packet = DhcpV4Packet::from_raw_bytes(&INPUT_DHCP_DISCOVER);
        let net_cfg = load_main_cfg("tests/main.yml").unwrap().network_cfg().clone();

        let mut registry: HookRegistry<DhcpV4Packet, DhcpV4Packet> = HookRegistry::new();
        registry.register_service(RwLock::new(net_cfg));
        let mut context: PacketContext<DhcpV4Packet, DhcpV4Packet> = PacketContext::from(input_packet);
        registry.register_hook(fp_core::core::state::PacketState::Received
            , Hook::new(String::from("responder_hook"), responder_hook(), Vec::new()));
        registry.run_hooks(&mut context).unwrap();

        let output = context.get_output();
        assert!(output.op == 2);
        assert!(output.xid == context.get_input().xid);
        assert!(output.options.server_identifier() == Some(Ipv4Addr::new(127, 0, 0, 1)));
        assert!(output.options.message_type() == Some(2));

    }

}
